# coding=utf-8

from sage.all import ZZ, copy
from sage.databases.cremona import cremona_letter_code
from nfscripts import ap_list, minimal_model, is_Q_curve, isModular, isomorphism_class_key
from fields import nf_lookup, add_field, field_data, cm_j_dict
from files import read_curves, read_curve_file, write_curve_file
from codec import ideal_from_string, ideal_to_string, ainvs_to_string, curve_from_strings, curve_from_data

# Originally adapted from Warren Moore's scripts.  The main function
# process_curves(curves) takes a list of elliptic curves and outputs
# data files.  Isogenous curves are computed and sorted.

def get_isoclass_letter(N, E):
    K = E.base_field()
    Kdata = field_data[K]
    Plist = Kdata['Plist'][:25]
    aplist = ap_list(E,Plist)
    try:
        nfs = Kdata['nf_data'][N]
    except KeyError: # No newform of this level at all
        n = Kdata['cm_counts'].get(N,0)
        Kdata['cm_counts'][N] = n+1
        return "CM"+cremona_letter_code(n)
    for id in nfs.keys():
        nfap = nfs[id]['ap'][:25]
        if nfap == aplist:
            return id

    # If we get to here, no newform of this level matches the ap
    #print("(2) No newform matches %s, conductor %s" % (E.ainvs(),N))
    n = Kdata['cm_counts'].get(N,0)
    Kdata['cm_counts'][N] = n+1
    return "CM"+cremona_letter_code(n) # 0->a, 1->b etc

# Check if we've already found this curve
def found(E, norm = None):
        r"""
        Return ``None`` iff this isomorphism class has not been encountered already.
        """
        if norm is None:
                norm = E.conductor().norm()
        curves = field_data[E.base_field()]['used_curves']
        if norm in curves:
            for E2 in curves[norm]:
                if E.is_isomorphic(E2):
                    return E2
        return None

# Main curve processing function
def process_curves(curves, outfile = None, classfile=None, verbose=0):
        r"""
        Given a list or iterator yielding a sequence of elliptic
        curves (which could be either an actual list of elliptic
        curves, or something like read_curves(file_name)), processses
        these and writes the results to an output file (if given) and
        to the screen (if verbose>0).

        The input curves do not have to be defined over the same base
        field; the output will be sorted first by field.

        Each curve is first compared with a list of curves previously
        encountered to see if it is isomorphic *or isogenous* to any
        of these, in which case it is ignored.  Hence, if the input
        file contains several curves in an isogeny class, all but the
        first will effectively be ignored.  After that the complete
        isogeny class is computed, sorted, and data for output
        computed for each curve.

        Finally, after all the input and processing are complete, the
        whole lot is output to the file and/or screen, sorted as
        follows: by field, then conductor norm, then conductor (sorted
        using the LMFDB ordering of ideals of the same norm), then by
        isogeny class (using the key ???), then by curves in the class
        (using the key isogeny_class_key).

        By default, the letter labels for isogeny classes are
        generated on the fly, which should be fine provided that the
        input is complete (at least one curve in every isogeny class)
        for each conductor present.

        Or, the 'curves' delivered by the iterator can be tuples
        (field_label, N_label, N_def, iso_label, c_num, E) in which
        case these will be used to construct labels (as for curves
        obtained from HMFs where we want to keep the isogeny class
        label as the same as the original HMF label).

        Or, they can be generated by comparison with the associated
        newform: currently only available for Bianchi newforms over
        K=Q(sqrt(-d)) for d=1,2,3,7,11.  In these cases, since curves
        with CM rational over K are not attached to Bianchi newforms,
        the letter labels are of the form "CMa", "CMb", etc and not
        just "a", "b", etc.  """
        if outfile:
                outfile = open(outfile, mode="a")
        if classfile:
                classfile = open(classfile, mode="a")

        data = {} # holds line to be output into the main output file,
                  # indexed by (1) field (2) conductor norm (3,4) HNF
                  # generators (only sufficient for quadratic fields!)
                  # i.e. data[k][n][c][d] is a list of strings to be
                  # output, each defining one curve over field k,
                  # conductor norm n, conductor HNF <n/d,c+d*alpha>
                  # where Z[alpha] is the ring of integers.

        isogdata = {} # ditto for isogeny classes & isog matrix data file.

        for E in curves:
                N_label = None
                field_label = None
                if isinstance(E,tuple):
                        field_label, N_label, N_def, iso_label, c_num, E = E
                        if verbose>0:
                                print("processing E = %s with conductor %s, label %s-%s%s over field %s" % (list(E.ainvs()),N_def,N_label,iso_label,c_num,field_label))
                else:
                        if verbose>0:
                                print("processing E = %s..." % list(E.ainvs()))
                k = E.base_field()
                add_field(k, field_label=field_label)
                kdata = field_data[k]
                used = kdata['used_curves']
                field_label = kdata['labels']
                nf_data_k = kdata['nf_data'] # may be None; that's ok
                # Set up 2 dicts to collect the data to be output after sorting:
                if not k in data:
                        data[k] = {}
                        isogdata[k] = {}
                data_k = data[k]
                isogdata_k = isogdata[k]

                E = minimal_model(E)
                N = E.conductor()
                norm = N.norm()
                if N_label:
                    if not norm==ZZ(N_label.split(".")[0]):
                        print("****************************")
                        print("Conductor norm = %s, does not match label %s" % (norm, N_label))
                        print("****************************")

                E2 = found(E, norm)
                if E2:
                    if verbose>0:
                        print(" -- isogenous to previous curve %s" % list(E2.ainvs()))
                else:
                        if verbose>1:
                                print(" -- new isogeny class")
                        # Conductor
                        hnf = N.pari_hnf()
                        if N_label:
                            cond_label = N_label
                            cond_def = N_def
                        else:
                            cond_def = "[%i,%s,%s]" % (norm, hnf[1][0], hnf[1][1])
                            cond_label = cond_def
                        if nf_data_k:
                            isog = get_isoclass_letter(cond_label,E)
                            if verbose>0:
                                print("Isogeny class label = %s.%s" % (cond_label,isog))
                        else:  # default
                            if N_label:
                                isog = iso_label
                            else:
                                isog = ":isog"

                        # Setup data
                        if norm not in data_k:
                                data_k[norm] = {}
                                isogdata_k[norm] = {}
                        if hnf[1][0] not in data_k[norm]:
                                data_k[norm][hnf[1][0]] = {}
                                isogdata_k[norm][hnf[1][0]] = {}
                        if hnf[1][1] not in data_k[norm][hnf[1][0]]:
                                data_k[norm][hnf[1][0]][hnf[1][1]] = []
                                isogdata_k[norm][hnf[1][0]][hnf[1][1]] = []
                        else:
                                # This is only useful if we input a
                                # curve which is isogenous to one
                                # already processed but is not
                                # isomorphic to any previously seen,
                                # which only happens if the isog_class
                                # function produced an incomplete list
                                # from the earlier curve!
                                ainvs = E.a_invariants()
                                for n, found_isog_class in enumerate(data_k[norm][hnf[1][0]][hnf[1][1]]):
                                        curve_data = found_isog_class[0].split()
                                        if E.is_isogenous(curve_from_strings(k, curve_data[6:11]), maxnorm=200):
                                                print("Warning: input curve %s isogenous to previous curve %s but not found by isogeny class computation!" % (list(E.ainvs()),curve_data[6:11]))
                                                curve_data[3] = len(found_isog_class)+1
                                                curve_data[6:11] = [",".join([str(c) for c in ai]) for ai in ainvs]
                                                data_k[norm][hnf[1][0]][hnf[1][1]][n].append(" ".join(curve_data))
                                                break

                        # Compute the isogeny class
                        if verbose>1:
                                print("computing the isogeny class")
                        Cl = E.isogeny_class()
                        clist0 = [minimal_model(C) for C in Cl.curves]
                        mat0 = Cl.matrix()
                        # sort into new order (will be redundant later)
                        clist = sorted(clist0, key=isomorphism_class_key)
                        # perm[i]=j where sorted#i = unsorted#j
                        perm = dict([(i,clist0.index(Ei)) for i,Ei in enumerate(clist)])
                        mat = copy(mat0) # to set the size etc
                        for i in range(len(clist)):
                                for j in range(len(clist)):
                                        mat[i,j] = mat0[perm[i],perm[j]]

                        if norm not in used:
                                used[norm] = []
                        if verbose and len(clist)>1:
                            print("Adding %s isogenous curves" % (len(clist)-1))
                            #for E2 in clist[1:]:
                            #    print list(E2.ainvs())
                        used[norm] += clist

                        matlist = str([list(r) for r in mat]).replace(' ','')
                        isogdata_line = "%s %s %s %i %s" % (field_label, cond_label, isog, 1, matlist)
                        isogdata_k[norm][hnf[1][0]][hnf[1][1]].append([isogdata_line])
                        if verbose>1:
                                print("isog_data: %s" % isogdata_line)

                        # Q-curve? (isogeny class invariant)
                        q_curve = int(is_Q_curve(E))
                        if verbose>1:
                            if q_curve=='?':
                                print("Q-curve status not determined")
                            else:
                                if q_curve:
                                    print("...Q-curve")
                                else:
                                    print("...not a Q-curve")

                        tmp = [] # list of output lines (with
                                 # placeholder for isog code, filled
                                 # in after sorting)

                        for n, E2 in enumerate(clist):
                                # a-invs
                                ainvs = E2.a_invariants()
                                ainv_string = ainvs_to_string(ainvs)
                                # Disc
                                j = E2.j_invariant()
                                disc = cm_j_dict.get(j, 0)

                                curve_line = "%s %s %s %i %s %i %s %i %s" % (field_label, cond_label, isog, n + 1, cond_def, norm, ainv_string, disc, q_curve)
                                if verbose>1:
                                        print("curve_line: %s" % curve_line)
                                tmp.append(curve_line)
                        data_k[norm][hnf[1][0]][hnf[1][1]].append(tmp)

        # Sort and output the data

        #print(data)
        ks = data.keys()
        if verbose>0:
                print()
                print("fields: {}".format(ks))
        for k in sorted(ks):
            data_k = data[k]
            isogdata_k = isogdata[k]
            norms = data_k.keys()
            for norm in sorted(norms):
                data_k_n = data_k[norm]
                isogdata_k_n = isogdata_k[norm]
                hnf0s = data_k_n.keys()
                for hnf0 in sorted(hnf0s):
                        data_k_n_h = data_k_n[hnf0]
                        isogdata_k_n_h = isogdata_k_n[hnf0]
                        hnf1s = data_k_n_h.keys()
                        for hnf1 in sorted(hnf1s):
                                dat = data_k_n_h[hnf1]
                                isogdat = isogdata_k_n_h[hnf1]
                                #dat.sort(cmp = isog_class_cmp)
                                for n, (cdata,isodata) in enumerate(zip(dat,isogdat)):
                                        isoline = isodata[0]
                                        if isog==":isog":
                                                isog_letter = cremona_letter_code(n)
                                                isoline = isoline.replace(":isog", isog_letter)
                                        if classfile:
                                                classfile.write(isoline+'\n')
                                        if verbose>0:
                                                print(isoline)
                                        for E_data in cdata:
                                                line = E_data
                                                if isog==":isog":
                                                        isog_letter = cremona_letter_code(n)
                                                        line = line.replace(":isog", isog_letter)
                                                if outfile:
                                                        outfile.write(line+'\n')
                                                if verbose>0:
                                                        print(line)

def run1(pth,fld):
    infile = "%s/curves1.%s" % (pth,fld)
    outfile = "%s/curves.%s" % (pth,fld)
    classfile = "%s/isoclass.%s" % (pth,fld)
    process_curves(read_curves(infile), outfile=outfile, classfile=classfile, verbose=1)

def run2(pth,fld):
    infile = "%s/curves2.%s" % (pth,fld)
    outfile = "%s/curves.%s" % (pth,fld)
    classfile = "%s/isoclass.%s" % (pth,fld)
    process_curves(read_curves(infile), outfile=outfile, classfile=classfile, verbose=1)

def fix_conductors(infile, outfile = None, verbose=False):
    """Read curves from infile, check that their conductors as defined in
    field #5 are correct, and if not replace them.
    """
    f = outfile
    if f:
        outfile = open(f,'w')
    for L in open(infile).readlines():
        data = L.split()
        if len(data)!=13:
            print("line {} does not have 13 fields, skipping".format(L))
            continue
        field_label = data[0]
        K = nf_lookup(field_label)
        E = curve_from_strings(K, data[6:11])
        NE = E.conductor()
        N_def = data[4]
        N = ideal_from_string(K, N_def)
        if N!=NE:
            print("\nN_def={} gives N={}, not NE={}, replacing".format(N_def,N,NE))
            data[4] = N_def = ideal_to_string(NE).replace(" ","")
            if verbose:
                print(L[:-1])
                print(" with")
        if f:
            if verbose:
                print("writing to {}: {}".format(f,data))
            outfile.write(" ".join(data)+"\n")
        if verbose:
            print(" ".join(data))
    if f:
        outfile.close()

def fix_conductor_ideals(infile, outfile = None, verbose=False):
    """Read curves from infile, replace the HNF-based format for
    conductors in field #5 with the general one.
    """
    f = outfile
    if f:
        outfile = open(f,'w')
    for L in open(infile).readlines():
        data = L.split()
        if len(data)!=13:
            print("line {} does not have 13 fields, skipping".format(L))
            continue
        field_label = data[0]
        K = nf_lookup(field_label)
        N_def = data[4]
        N = ideal_from_string(K, N_def, True) # input in IQF_format
        if N=="wrong":
            raise ValueError
        data[4] = N_def = ideal_to_string(N, False) # output in standard format
        if f:
            if verbose:
                print("writing to {}: {}".format(f,data))
            outfile.write(" ".join(data)+"\n")
        if verbose:
            print(" ".join(data))
    if f:
        outfile.close()

def check_modularity(pth,fld, verbose=False):
    f = "{}/curves.{}".format(pth,fld)
    #print("reading curves from {}".format(f))
    ntrue = 0
    nfalse = 0
    nall = 0
    for data in read_curves(f):
        field_label, N_label, N_def, iso_label, c_num, E = data
        if c_num != '1':
            continue
        c_label = N_label+"-"+iso_label+c_num
        full_label = field_label+"-"+c_label
        nall += 1
        if isModular(E):
            ntrue +=1
            if verbose: print("{} is modular".format(full_label))
        else:
            nfalse +=1
            if verbose: print("{}: could not check modularity".format(full_label))
    if ntrue==nall:
        print("All {} curves over {} were proved to be modular!".format(ntrue,field_label))
    else:
        print("Only {} out of {} curves over {} were proved to be modular!".format(ntrue,nall, field_label))

def check_Q_curve_flags(filename, output=False, verbose=True):
    curves = list(read_curve_file(filename))
    ncurves = len(curves)
    if verbose:
        print("Read {} curves from {}".format(ncurves, filename))
    nall = 0
    nbad = 0
    nbad01 = 0
    nbad10 = 0
    cache = {} # dict of class_label:flag
    for c in curves:
        old_flag = c['q_curve_flag']
        if old_flag=='?' and not output:
            continue
        nall += 1

        class_label = "-".join([c['field_label'], c['N_label'], c['iso_label']])

        if class_label in cache:
            flag = cache[class_label]
        else:
            flag = is_Q_curve(curve_from_data(c),c['field_label'],verbose) # True, False, '?'
            cache[class_label] = flag

        if flag != '?':
            flag = str(int(flag))
        if verbose:
            print("Q-curve flag (computed): {}".format(flag))
            print("Q-curve flag (file):     {}".format(old_flag))
        #assert flag!='?'
        if old_flag!='?' and flag != old_flag:
            print("curve {}: flag on file is {} but should be {}".format(c,old_flag,flag))
            nbad += 1
        if [old_flag, flag] == ['0','1']:
            nbad01 += 1
        if [old_flag, flag] == ['1','0']:
            nbad10 += 1

        c['q_curve_flag'] = flag # a string, either '0' or '1'

    if output:
        newfilename = filename+".qc_fix"
        print("Writing revised curves file to {}".format(newfilename))
        write_curve_file(curves,newfilename)

    print("{} out of {} curves had incorrect Q-curve flag".format(nbad,nall))
    if nbad:
        print("In {} cases flag on file was 0, new flag is 1".format(nbad01))
        print("In {} cases flag on file was 1, new flag is 0".format(nbad10))
